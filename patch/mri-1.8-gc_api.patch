diff --git a/gc.c b/gc.c
index fa45cd1..b2c933b 100644
--- a/gc.c
+++ b/gc.c
@@ -18,6 +18,7 @@
 #include "node.h"
 #include "env.h"
 #include "re.h"
+#include "gc_api.h"
 #include <stdio.h>
 #include <setjmp.h>
 #include <sys/types.h>
@@ -1134,6 +1135,8 @@ gc_sweep()
     unsigned long live = 0;
     unsigned long free_min = 0;
 
+    rb_gc_invoke_callbacks(RB_GC_PHASE_SWEEP, RB_GC_PHASE_BEFORE); 
+
     for (i = 0; i < heaps_used; i++) {
         free_min += heaps[i].limit;
     }
@@ -1216,10 +1219,14 @@ gc_sweep()
     }
     malloc_increase = 0;
     if (freed < free_min) {
+	rb_gc_invoke_callbacks(RB_GC_PHASE_ALLOC, RB_GC_PHASE_BEFORE);
 	add_heap();
+	rb_gc_invoke_callbacks(RB_GC_PHASE_ALLOC, RB_GC_PHASE_AFTER);
     }
     during_gc = 0;
 
+    rb_gc_invoke_callbacks(RB_GC_PHASE_SWEEP, RB_GC_PHASE_AFTER); 
+
     /* clear finalization list */
     if (final_list) {
 	deferred_final_list = final_list;
@@ -1230,7 +1237,9 @@ gc_sweep()
 	    rb_thread_pending = 1;
 	}
 	if (!freelist) {
+            rb_gc_invoke_callbacks(RB_GC_PHASE_ALLOC, RB_GC_PHASE_BEFORE);
 	    add_heap();
+            rb_gc_invoke_callbacks(RB_GC_PHASE_ALLOC, RB_GC_PHASE_AFTER);
 	}
 	return;
     }
@@ -1440,13 +1449,20 @@ garbage_collect()
 #endif
     if (dont_gc || during_gc) {
 	if (!freelist) {
+            rb_gc_invoke_callbacks(RB_GC_PHASE_ALLOC, RB_GC_PHASE_BEFORE);
 	    add_heap();
+            rb_gc_invoke_callbacks(RB_GC_PHASE_ALLOC, RB_GC_PHASE_AFTER);
 	}
 	return;
     }
     if (during_gc) return;
     during_gc++;
 
+    rb_gc_invoke_callbacks(RB_GC_PHASE_START, RB_GC_PHASE_BEFORE);
+    rb_gc_invoke_callbacks(RB_GC_PHASE_START, RB_GC_PHASE_AFTER);
+
+    rb_gc_invoke_callbacks(RB_GC_PHASE_MARK, RB_GC_PHASE_BEFORE);
+
     init_mark_stack();
 
     gc_mark((VALUE)ruby_current_node, 0);
@@ -1521,7 +1537,12 @@ garbage_collect()
 	rb_gc_abort_threads();
     } while (!MARK_STACK_EMPTY);
 
+    rb_gc_invoke_callbacks(RB_GC_PHASE_MARK, RB_GC_PHASE_AFTER);
+
     gc_sweep();
+
+    rb_gc_invoke_callbacks(RB_GC_PHASE_END, RB_GC_PHASE_BEFORE);
+    rb_gc_invoke_callbacks(RB_GC_PHASE_END, RB_GC_PHASE_AFTER);
 }
 
 void
@@ -1979,10 +2000,15 @@ rb_gc_finalize_deferred()
     RVALUE *p = deferred_final_list;
 
     deferred_final_list = 0;
+
+    rb_gc_invoke_callbacks(RB_GC_PHASE_FINALIZE, RB_GC_PHASE_BEFORE);
+
     if (p) {
 	finalize_list(p);
 	free_unused_heaps();
     }
+
+    rb_gc_invoke_callbacks(RB_GC_PHASE_FINALIZE, RB_GC_PHASE_AFTER);
 }
 
 void
@@ -1991,6 +2017,8 @@ rb_gc_call_finalizer_at_exit()
     RVALUE *p, *pend;
     int i;
 
+    rb_gc_invoke_callbacks(RB_GC_PHASE_FINALIZE, RB_GC_PHASE_BEFORE);
+ 
     /* run finalizers */
     if (need_call_final && finalizer_table) {
 	p = deferred_final_list;
@@ -2033,6 +2061,11 @@ rb_gc_call_finalizer_at_exit()
 	    p++;
 	}
     }
+
+    rb_gc_invoke_callbacks(RB_GC_PHASE_FINALIZE, RB_GC_PHASE_AFTER);
+
+    rb_gc_invoke_callbacks(RB_GC_PHASE_AT_EXIT, RB_GC_PHASE_BEFORE);
+    rb_gc_invoke_callbacks(RB_GC_PHASE_AT_EXIT, RB_GC_PHASE_AFTER);
 }
 
 /*
